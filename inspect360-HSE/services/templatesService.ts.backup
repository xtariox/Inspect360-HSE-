import { supabase } from '../config/supabase';
import { InspectionTemplate } from '../types/inspection';

export class TemplatesService {
  // Get all te  static async saveTemplate(template: InspectionTemplate): Promise<InspectionTemplate> {
    try {
      console.log('üíæ Saving template to database...', template.title);
      
      const templateData: any = {
        title: template.title,
        description: template.description || '',
        category: template.category,
        tags: template.tags || [],
        sections: template.sections || [],
        created_by: template.createdBy,
        is_prebuilt: template.isPrebuilt || false,
        is_active: true
      };

      // Include ID for updates (upsert will use it for matching)
      if (template.id) {
        templateData.id = template.id;
      }tic async getAllTemplates(): Promise<InspectionTemplate[]> {
    try {
      console.log('üîç Fetching all templates with creator names...');
      
      const { data, error } = await supabase
        .from('templates')
        .select(`
          id,
          title,
          description,
          category,
          tags,
          sections,
          created_by,
          created_at,
          updated_at,
          is_active,
          is_prebuilt,
          status
        `)
        .or('is_active.eq.true,status.eq.draft') // Include active templates and drafts
        .order('created_at', { ascending: false });

      if (error) {
        console.error('‚ùå Error fetching templates:', error);
        throw error;
      }

      console.log('‚úÖ Templates fetched successfully:', data?.length || 0);

      return (data || []).map(template => this.mapSupabaseToTemplate(template));
    } catch (error) {
      console.error('‚ùå Error in getAllTemplates:', error);
      return []; // Return empty array instead of fallback templates
    }
  }

  // Get prebuilt templates only
  static async getPrebuiltTemplates(): Promise<InspectionTemplate[]> {
    try {
      console.log('üîç Fetching prebuilt templates...');
      
      const { data, error } = await supabase
        .from('templates')
        .select(`
          id,
          title,
          description,
          category,
          tags,
          sections,
          created_by,
          created_at,
          updated_at,
          is_active,
          is_prebuilt
        `)
        .eq('is_prebuilt', true)
        .eq('is_active', true)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('‚ùå Error fetching prebuilt templates:', error);
        console.log('üîÑ Returning empty array instead of fallback templates...');
        return [];
      }

      console.log('‚úÖ Prebuilt templates fetched successfully:', data?.length || 0);
      console.log('üìã Template details:', data?.map(t => ({ id: t.id, title: t.title, sectionCount: Array.isArray(t.sections) ? t.sections.length : 0 })));
      
      return data?.map(this.mapSupabaseToTemplate) || [];
    } catch (error) {
      console.error('‚ùå Error in getPrebuiltTemplates:', error);
      return []; // Return empty array instead of fallback templates
    }
  }

  // Get user-created templates
  static async getUserTemplates(userId: string): Promise<InspectionTemplate[]> {
    try {
      console.log('üîç Fetching user templates for:', userId);
      
      const { data, error } = await supabase
        .from('templates')
        .select(`
          *,
          creator:user_profiles!left(
            id,
            full_name,
            email
          )
        `)
        .eq('created_by', userId)
        .eq('is_active', true)
        .order('updated_at', { ascending: false });

      if (error) {
        console.error('‚ùå Error fetching user templates:', error);
        throw error;
      }

      console.log('‚úÖ User templates fetched successfully:', data?.length || 0);

      return (data || []).map(template => this.mapSupabaseToTemplate(template));
    } catch (error) {
      console.error('‚ùå Error in getUserTemplates:', error);
      return [];
    }
  }

  // Get template by ID
  static async getTemplateById(templateId: string): Promise<InspectionTemplate | null> {
    try {
      console.log('üìã Fetching template by ID:', templateId);

      const { data, error } = await supabase
        .from('templates')
        .select(`
          *,
          user_profiles!templates_created_by_fkey(
            id,
            full_name,
            email
          )
        `)
        .eq('id', templateId)
        .eq('is_active', true)
        .single();

      if (error) {
        if (error.code === 'PGRST116') { // Not found
          console.log('‚ö†Ô∏è Template not found:', templateId);
          return null;
        }
        console.error('‚ùå Error fetching template by ID:', error);
        throw error;
      }

      if (!data) {
        console.log('‚ö†Ô∏è No template data returned for ID:', templateId);
        return null;
      }

      console.log('‚úÖ Template fetched successfully:', data.title);
      return this.mapSupabaseToTemplate(data);
    } catch (error) {
      console.error('‚ùå Error in getTemplateById:', error);
      return null;
    }
  }

  // Save template
  static async saveTemplate(template: InspectionTemplate): Promise<InspectionTemplate> {
    try {
      console.log('ÔøΩ Saving template to database...', template.title);
      
      const templateData = {
        title: template.title,
        description: template.description || '',
        category: template.category,
        tags: template.tags || [],
        sections: template.sections || [],
        created_by: template.createdBy,
        is_prebuilt: template.isPrebuilt || false,
        is_active: true
      };

      const { data, error } = await supabase
        .from('templates')
        .upsert(templateData)
        .select(`
          *,
          user_profiles!templates_created_by_fkey(
            id,
            full_name,
            email
          )
        `)
        .single();

      if (error) {
        console.error('‚ùå Error saving template:', error);
        throw error;
      }

      console.log('‚úÖ Template saved successfully:', data.id);
      return this.mapSupabaseToTemplate(data);
    } catch (error) {
      console.error('‚ùå Error in saveTemplate:', error);
      throw error;
    }
  }

  // Save template as draft
  static async saveDraft(template: Partial<InspectionTemplate>): Promise<InspectionTemplate> {
    try {
      console.log('üìù Saving template as draft...', template.title);
      
      const templateData = {
        id: template.id || this.generateUUID(),
        title: template.title || 'Draft Template',
        description: template.description || '',
        category: template.category || 'general',
        tags: template.tags || [],
        sections: template.sections || [],
        created_by: template.createdBy,
        is_prebuilt: false,
        is_active: false, // Drafts are inactive
        status: 'draft'
      };

      console.log('üìù Template data to save:', templateData);

      const { data, error } = await (supabase as any)
        .from('templates')
        .insert([templateData])
        .select()
        .single();

      if (error) {
        console.error('‚ùå Error saving template draft:', error);
        throw error;
      }

      if (!data) {
        throw new Error('No data returned from template save operation');
      }

      console.log('‚úÖ Template draft saved successfully:', (data as any).id);
      return this.mapSupabaseToTemplate(data as any);
    } catch (error) {
      console.error('‚ùå Error in saveDraft:', error);
      throw error;
    }
  }

  private static generateUUID(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  // Update template
  static async updateTemplate(id: string, updates: Partial<InspectionTemplate>): Promise<InspectionTemplate> {
    try {
      console.log('üìù Updating template:', id);
      
      const updateData: any = {};
      
      if (updates.title) updateData.title = updates.title;
      if (updates.description !== undefined) updateData.description = updates.description;
      if (updates.category) updateData.category = updates.category;
      if (updates.tags) updateData.tags = updates.tags;
      if (updates.sections) updateData.sections = updates.sections;
      if (updates.status) updateData.status = updates.status;
      if (updates.isActive !== undefined) updateData.is_active = updates.isActive;
      
      updateData.updated_at = new Date().toISOString();

      const { data, error } = await (supabase as any)
        .from('templates')
        .update(updateData)
        .eq('id', id)
        .select('*')
        .single();

      if (error) {
        console.error('‚ùå Error updating template:', error);
        throw error;
      }

      if (!data) {
        throw new Error('No data returned from template update operation');
      }

      console.log('‚úÖ Template updated successfully');
      return this.mapSupabaseToTemplate(data);
    } catch (error) {
      console.error('‚ùå Error in updateTemplate:', error);
      throw error;
    }
  }

  // Delete template
  static async deleteTemplate(templateId: string): Promise<void> {
    try {
      const { error } = await (supabase as any)
        .from('templates')
        .update({ is_active: false })
        .eq('id', templateId);

      if (error) throw error;
    } catch (error) {
      console.error('Error deleting template:', error);
      throw error;
    }
  }

  // Clean up corrupted templates in database
  static async cleanupCorruptedTemplates(): Promise<void> {
    try {
      console.log('üßπ Starting template cleanup...');
      
      // Get all templates
      const { data: templates, error } = await supabase
        .from('templates')
        .select('*');

      if (error) {
        console.error('‚ùå Error fetching templates for cleanup:', error);
        return;
      }

      let cleanedCount = 0;
      
      for (const template of templates || []) {
        let needsUpdate = false;
        const sections = template.sections;
        
        if (Array.isArray(sections)) {
          sections.forEach((section: any, index: number) => {
            if (!Array.isArray(section.fields)) {
              console.log(`üîß Fixing template "${template.title}" section ${index} - adding empty fields array`);
              section.fields = [];
              needsUpdate = true;
            }
          });
          
          if (needsUpdate) {
            const { error: updateError } = await supabase
              .from('templates')
              .update({ sections: sections })
              .eq('id', template.id);
              
            if (updateError) {
              console.error(`‚ùå Failed to update template ${template.id}:`, updateError);
            } else {
              console.log(`‚úÖ Updated template "${template.title}"`);
              cleanedCount++;
            }
          }
        }
      }
      
      console.log(`üßπ Template cleanup complete. Fixed ${cleanedCount} templates.`);
    } catch (error) {
      console.error('‚ùå Error during template cleanup:', error);
    }
  }

  // Initialize prebuilt templates in database
  static async initializePrebuiltTemplates(): Promise<void> {
    try {
      console.log('üèóÔ∏è Initializing prebuilt templates...');
      
      // First, clean up any corrupted templates
      await this.cleanupCorruptedTemplates();
      
      const defaultTemplates = this.getDefaultTemplates();
      console.log(`üìã Found ${defaultTemplates.length} default templates to initialize`);
      
      for (const template of defaultTemplates) {
        const supabaseTemplate = this.mapTemplateToSupabase(template);
        
        // Check if template already exists by ID and title (for extra safety)
        const { data: existing, error: checkError } = await supabase
          .from('templates')
          .select('id, title')
          .eq('id', supabaseTemplate.id)
          .maybeSingle();

        if (checkError && checkError.code !== 'PGRST116') {
          console.error('Error checking existing template:', checkError);
          continue;
        }

        if (!existing) {
          console.log(`‚ûï Inserting new prebuilt template: "${template.title}"`);
          // Only insert if template doesn't exist
          const { error: insertError } = await supabase
            .from('templates')
            .insert([supabaseTemplate]);

          if (insertError) {
            console.error('‚ùå Error initializing template:', template.title, insertError);
          } else {
            console.log(`‚úÖ Successfully inserted template: "${template.title}"`);
          }
        } else {
          console.log(`‚è≠Ô∏è Template already exists, skipping: "${template.title}"`);
        }
      }
      
      console.log('üèÅ Prebuilt template initialization complete');
    } catch (error) {
      console.error('‚ùå Error initializing prebuilt templates:', error);
    }
  }

  // Map Supabase data to InspectionTemplate
  private static mapSupabaseToTemplate(data: any): InspectionTemplate {
    console.log('üîÑ Mapping Supabase data to template:', {
      id: data.id,
      title: data.title,
      sectionsType: typeof data.sections,
      sectionsIsArray: Array.isArray(data.sections),
      sectionsLength: data.sections?.length,
      firstSection: data.sections?.[0]
    });

    // Detailed section and field analysis
    if (Array.isArray(data.sections)) {
      data.sections.forEach((section: any, sectionIndex: number) => {
        console.log(`üìã Section ${sectionIndex}:`, {
          sectionId: section.id,
          sectionTitle: section.title,
          fieldsType: typeof section.fields,
          fieldsIsArray: Array.isArray(section.fields),
          fieldsLength: section.fields?.length
        });

        // Fix missing fields array
        if (!Array.isArray(section.fields)) {
          console.error(`‚ùå Section ${sectionIndex} fields is not an array:`, section.fields);
          console.log(`üîß Fixing section ${sectionIndex} by adding empty fields array`);
          section.fields = []; // Fix the section by adding empty fields array
        } else {
          section.fields.forEach((field: any, fieldIndex: number) => {
            console.log(`üîç Field ${sectionIndex}.${fieldIndex}:`, {
              fieldId: field.id,
              fieldLabel: field.label,
              fieldType: field.type,
              fieldRequired: field.required,
              hasType: !!field.type,
              hasLabel: !!field.label,
              hasId: !!field.id,
              fullField: field
            });

            if (!field.type) {
              console.error(`‚ùå Field missing type in section ${sectionIndex}, field ${fieldIndex}:`, field);
            }
          });
        }
      });
    }

    return {
      id: data.id,
      title: data.title,
      description: data.description || '',
      category: data.category,
      tags: data.tags || [],
      sections: Array.isArray(data.sections) ? data.sections : [],
      createdBy: data.created_by || 'system', // Handle NULL created_by for prebuilt templates
      createdByName: data.user_profiles?.full_name || 
                    data.user_profiles?.email || 
                    (data.is_prebuilt ? 'System' : 'Unknown User'),
      createdAt: data.created_at,
      updatedAt: data.updated_at,
      isActive: data.is_active,
      isPrebuilt: data.is_prebuilt,
      status: data.status || 'active' // Handle the new status field with backward compatibility
    };
  }

  // Map InspectionTemplate to Supabase format
  private static mapTemplateToSupabase(template: InspectionTemplate): any {
    console.log('üîÑ TemplatesService - Mapping template to Supabase format:', {
      originalId: template.id,
      title: template.title,
      createdBy: template.createdBy
    });
    
    return {
      id: template.id,
      title: template.title,
      description: template.description,
      category: template.category,
      tags: template.tags,
      sections: template.sections,
      created_by: template.createdBy,
      created_at: template.createdAt,
      updated_at: template.updatedAt,
      is_active: template.isActive,
      is_prebuilt: template.isPrebuilt,
      status: template.status || 'active' // Include status field
    };
  }

  // Generate a simple UUID-like string for templates
  private static generateTemplateId(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  // Default templates as fallback
  private static getDefaultTemplates(): InspectionTemplate[] {
    return [
      {
        id: 'prebuilt-safety-inspection-v1',
        title: 'Safety Inspection Checklist',
        description: 'Comprehensive safety inspection for workplace environments',
        category: 'safety',
        tags: ['safety', 'workplace', 'checklist'],
        sections: [
          {
            id: 1,
            title: 'General Information',
            description: 'Basic inspection details',
            fields: [
              { 
                id: 'inspector', 
                label: 'Inspector Name', 
                type: 'text', 
                required: true,
                placeholder: 'Enter inspector full name'
              },
              { 
                id: 'date', 
                label: 'Inspection Date', 
                type: 'date', 
                required: true 
              },
              { 
                id: 'location', 
                label: 'Location', 
                type: 'text', 
                required: true,
                placeholder: 'Enter location or area being inspected'
              },
              { 
                id: 'time', 
                label: 'Inspection Time', 
                type: 'time', 
                required: true 
              }
            ]
          },
          {
            id: 2,
            title: 'Safety Equipment',
            description: 'Assessment of safety equipment availability and condition',
            fields: [
              { 
                id: 'fire_extinguisher', 
                label: 'Fire Extinguisher Present', 
                type: 'boolean', 
                required: true 
              },
              { 
                id: 'first_aid', 
                label: 'First Aid Kit Available', 
                type: 'boolean', 
                required: true 
              },
              { 
                id: 'safety_signs', 
                label: 'Safety Signage Visible', 
                type: 'boolean', 
                required: true 
              },
              { 
                id: 'emergency_exits', 
                label: 'Emergency Exits Clear', 
                type: 'boolean', 
                required: true 
              },
              { 
                id: 'safety_notes', 
                label: 'Additional Safety Notes', 
                type: 'textarea', 
                required: false,
                placeholder: 'Enter any additional safety observations or concerns'
              }
            ]
          },
          {
            id: 3,
            title: 'Documentation',
            description: 'Photo evidence and overall assessment',
            fields: [
              { 
                id: 'photo_evidence', 
                label: 'Photo Evidence', 
                type: 'image', 
                required: false,
                placeholder: 'Take photo of safety equipment or hazards'
              },
              { 
                id: 'overall_rating', 
                label: 'Overall Safety Rating', 
                type: 'select', 
                required: true, 
                options: ['Excellent', 'Good', 'Fair', 'Poor', 'Critical'] 
              }
            ]
          }
        ],
        createdBy: 'System',
        createdAt: '2024-01-01T00:00:00Z',
        updatedAt: '2024-01-01T00:00:00Z',
        isActive: true,
        isPrebuilt: true
      },
      {
        id: 'prebuilt-equipment-maintenance-v1',
        title: 'Equipment Maintenance Check',
        description: 'Regular maintenance inspection for equipment and machinery',
        category: 'maintenance',
        tags: ['maintenance', 'equipment', 'machinery'],
        sections: [
          {
            id: 1,
            title: 'Equipment Details',
            description: 'Basic equipment information',
            fields: [
              { 
                id: 'equipment_id', 
                label: 'Equipment ID', 
                type: 'text', 
                required: true,
                placeholder: 'Enter equipment identification number'
              },
              { 
                id: 'equipment_type', 
                label: 'Equipment Type', 
                type: 'select', 
                required: true, 
                options: ['Machinery', 'Vehicle', 'Tool', 'HVAC', 'Electrical', 'Other'] 
              },
              { 
                id: 'last_maintenance', 
                label: 'Last Maintenance Date', 
                type: 'date', 
                required: true 
              },
              { 
                id: 'maintenance_time', 
                label: 'Maintenance Time', 
                type: 'time', 
                required: true 
              }
            ]
          },
          {
            id: 2,
            title: 'Condition Assessment',
            description: 'Detailed condition evaluation',
            fields: [
              { 
                id: 'overall_condition', 
                label: 'Overall Condition', 
                type: 'select', 
                required: true, 
                options: ['Excellent', 'Good', 'Fair', 'Poor', 'Requires Immediate Attention'] 
              },
              { 
                id: 'visual_inspection', 
                label: 'Visual Inspection Passed', 
                type: 'boolean', 
                required: true 
              },
              { 
                id: 'operational_test', 
                label: 'Operational Test Passed', 
                type: 'boolean', 
                required: true 
              },
              { 
                id: 'safety_check', 
                label: 'Safety Features Working', 
                type: 'boolean', 
                required: true 
              },
              { 
                id: 'issues_found', 
                label: 'Issues Found', 
                type: 'textarea', 
                required: false,
                placeholder: 'Describe any issues or problems identified'
              },
              { 
                id: 'maintenance_recommendations', 
                label: 'Maintenance Recommendations', 
                type: 'textarea', 
                required: false,
                placeholder: 'Suggest maintenance actions or repairs needed'
              },
              { 
                id: 'photo', 
                label: 'Equipment Photo', 
                type: 'image', 
                required: false,
                placeholder: 'Take photo of equipment condition'
              }
            ]
          }
        ],
        createdBy: 'System',
        createdAt: '2024-01-01T00:00:00Z',
        updatedAt: '2024-01-01T00:00:00Z',
        isActive: true,
        isPrebuilt: true
      },
      {
        id: 'prebuilt-environmental-compliance-v1',
        title: 'Environmental Compliance Audit',
        description: 'Environmental compliance inspection and audit checklist',
        category: 'environmental',
        tags: ['environmental', 'compliance', 'audit'],
        sections: [
          {
            id: 1,
            title: 'General Information',
            description: 'Audit basic information',
            fields: [
              { 
                id: 'auditor', 
                label: 'Auditor Name', 
                type: 'text', 
                required: true,
                placeholder: 'Enter auditor full name'
              },
              { 
                id: 'audit_date', 
                label: 'Audit Date', 
                type: 'date', 
                required: true 
              },
              { 
                id: 'facility_name', 
                label: 'Facility Name', 
                type: 'text', 
                required: true,
                placeholder: 'Enter facility or site name'
              },
              { 
                id: 'permit_number', 
                label: 'Environmental Permit Number', 
                type: 'text', 
                required: false,
                placeholder: 'Enter permit number if applicable'
              }
            ]
          },
          {
            id: 2,
            title: 'Waste Management',
            description: 'Waste handling and disposal assessment',
            fields: [
              { 
                id: 'waste_segregation', 
                label: 'Proper Waste Segregation', 
                type: 'boolean', 
                required: true 
              },
              { 
                id: 'hazardous_storage', 
                label: 'Hazardous Waste Properly Stored', 
                type: 'boolean', 
                required: true 
              },
              { 
                id: 'disposal_records', 
                label: 'Disposal Records Available', 
                type: 'boolean', 
                required: true 
              },
              { 
                id: 'waste_notes', 
                label: 'Waste Management Notes', 
                type: 'textarea', 
                required: false,
                placeholder: 'Note any waste management issues or recommendations'
              }
            ]
          },
          {
            id: 3,
            title: 'Emissions & Discharges',
            description: 'Environmental emissions compliance',
            fields: [
              { 
                id: 'air_emissions', 
                label: 'Air Emissions Within Limits', 
                type: 'boolean', 
                required: true 
              },
              { 
                id: 'water_discharge', 
                label: 'Water Discharge Compliant', 
                type: 'boolean', 
                required: true 
              },
              { 
                id: 'monitoring_records', 
                label: 'Monitoring Records Up to Date', 
                type: 'boolean', 
                required: true 
              },
              { 
                id: 'compliance_rating', 
                label: 'Overall Compliance Rating', 
                type: 'select', 
                required: true, 
                options: ['Fully Compliant', 'Minor Issues', 'Major Issues', 'Non-Compliant'] 
              }
            ]
          }
        ],
        createdBy: 'System',
        createdAt: '2024-01-01T00:00:00Z',
        updatedAt: '2024-01-01T00:00:00Z',
        isActive: true,
        isPrebuilt: true
      }
    ];
  }

  // Comprehensive template and field diagnostics
  static async diagnoseTemplateIssues(): Promise<void> {
    try {
      console.log('üîç Starting comprehensive template diagnostics...');
      
      const { data: templates, error } = await supabase
        .from('templates')
        .select('*')
        .eq('is_active', true);

      if (error) {
        console.error('‚ùå Error fetching templates for diagnostics:', error);
        return;
      }

      console.log(`üìä Analyzing ${templates?.length || 0} active templates...`);

      let totalIssues = 0;
      const issuesByTemplate: any[] = [];

      for (const template of templates || []) {
        const templateIssues: any = {
          id: template.id,
          title: template.title,
          issues: []
        };

        // Check if sections exist and are valid
        if (!template.sections) {
          templateIssues.issues.push('Template has no sections property');
        } else if (!Array.isArray(template.sections)) {
          templateIssues.issues.push('Sections is not an array');
        } else {
          // Analyze each section
          template.sections.forEach((section: any, sectionIndex: number) => {
            const sectionPrefix = `Section ${sectionIndex + 1} ("${section.title || 'Untitled'}")`;
            
            if (!section.title) {
              templateIssues.issues.push(`${sectionPrefix}: Missing title`);
            }
            
            if (!section.fields) {
              templateIssues.issues.push(`${sectionPrefix}: Missing fields property`);
            } else if (!Array.isArray(section.fields)) {
              templateIssues.issues.push(`${sectionPrefix}: Fields is not an array`);
            } else if (section.fields.length === 0) {
              templateIssues.issues.push(`${sectionPrefix}: No fields configured`);
            } else {
              // Analyze each field
              section.fields.forEach((field: any, fieldIndex: number) => {
                const fieldPrefix = `${sectionPrefix} Field ${fieldIndex + 1}`;
                
                if (!field.id) {
                  templateIssues.issues.push(`${fieldPrefix}: Missing id`);
                }
                if (!field.label) {
                  templateIssues.issues.push(`${fieldPrefix}: Missing label`);
                }
                if (!field.type) {
                  templateIssues.issues.push(`${fieldPrefix}: Missing type`);
                } else {
                  const validTypes = ['text', 'number', 'textarea', 'boolean', 'date', 'time', 'image', 'select'];
                  if (!validTypes.includes(field.type)) {
                    templateIssues.issues.push(`${fieldPrefix}: Invalid type "${field.type}"`);
                  }
                }
                
                if (field.type === 'select' && (!field.options || !Array.isArray(field.options) || field.options.length === 0)) {
                  templateIssues.issues.push(`${fieldPrefix}: Select field missing options`);
                }
              });
            }
          });
        }

        if (templateIssues.issues.length > 0) {
          issuesByTemplate.push(templateIssues);
          totalIssues += templateIssues.issues.length;
        }
      }

      // Report findings
      console.log(`üéØ Template diagnostics complete:`);
      console.log(`   ‚Ä¢ Total templates analyzed: ${templates?.length || 0}`);
      console.log(`   ‚Ä¢ Templates with issues: ${issuesByTemplate.length}`);
      console.log(`   ‚Ä¢ Total issues found: ${totalIssues}`);

      if (issuesByTemplate.length > 0) {
        console.log('\nüìã Issue Details:');
        issuesByTemplate.forEach(template => {
          console.log(`\n‚ùå Template: "${template.title}" (ID: ${template.id})`);
          template.issues.forEach((issue: string) => {
            console.log(`   ‚Ä¢ ${issue}`);
          });
        });
      } else {
        console.log('‚úÖ No issues found in any templates!');
      }

    } catch (error) {
      console.error('‚ùå Error during template diagnostics:', error);
    }
  }
}
